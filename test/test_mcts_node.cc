#include "gtest/gtest.h"

#include <cstdio>
#include <stdlib.h>
#include <time.h>

#include "chess/game.h"
#include "mcts/node.h"

class MCTSNodeTest : public ::testing::Test {
 protected:
	MCTSNodeTest() : game_{}, root_{game_} {
		srand((unsigned)time(NULL));
	}

	using MCTSNode = aithena::MCTSNode<aithena::chess::Game>;

	void SetUp() {
		root_ = MCTSNode(game_);
	}

	aithena::chess::Game game_;
	MCTSNode root_;
};

TEST_F(MCTSNodeTest, InitializesCorrectly) {
	ASSERT_TRUE(game_.GetInitialState() == root_.GetState());
	ASSERT_EQ(root_.GetParent(), nullptr);
}

// Tests whether MCTSNode::Expand works correctly by checking the child node's
// states against the states generated by
// game_.GetInitialState().GetLegalActions().
TEST_F(MCTSNodeTest, ExpandsCorrectly) {
	auto start = game_.GetInitialState();

	MCTSNode::Child current_node{&root_, [](MCTSNode *) {}};

	unsigned i = 0;
	while (!(*current_node).IsTerminal() && i < 300) {
		MCTSNode& node = *current_node;
		node.Expand();

		ASSERT_TRUE(node.IsExpanded());

		auto children = node.GetChildren();
		auto legal_actions = game_.GetLegalActions(node.GetState());

		ASSERT_EQ(children.size(), legal_actions.size());

		// check if a node child exists for each legal action.
		for (aithena::chess::State state : legal_actions) {
			std::vector<MCTSNode::Child>::iterator it{children.begin()};
			while (it != children.end()) {
				if ((**it).GetState() == state) break;
				++it;
			}

			ASSERT_FALSE(it == children.end()); // legal action not in children
		}

		current_node = children.at(rand() % children.size());
		i++;
	}
}
